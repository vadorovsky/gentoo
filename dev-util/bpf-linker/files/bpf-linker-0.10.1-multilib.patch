From 7512286ca4ebd8aba7bbd25d5cf66730e33f0ab8 Mon Sep 17 00:00:00 2001
From: Michal R <vad.sol@proton.me>
Date: Sun, 1 Feb 2026 10:22:30 +0100
Subject: [PATCH] build: Ensure that linked libraries are of expected
 architecture

On multiarch environments, simply searching for libraries matching by
name might pull in libraries incompatible with the target we are
building for.
---
 build.rs | 566 ++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 374 insertions(+), 192 deletions(-)

diff --git a/build.rs b/build.rs
index 9eb688b0..6e268b0f 100644
--- a/build.rs
+++ b/build.rs
@@ -1,7 +1,7 @@
 use std::{
     borrow::Cow,
     env,
-    ffi::{OsStr, OsString},
+    ffi::{OsStr, OsString, os_str},
     fmt::{self, Display, Formatter},
     fs,
     io::{self, Write as _},
@@ -12,7 +12,7 @@ use std::{
 };
 
 use anyhow::{Context as _, anyhow};
-use object::{Object as _, ObjectSymbol as _, read::archive::ArchiveFile};
+use object::{Architecture, Object as _, ObjectSymbol as _, read::archive::ArchiveFile};
 
 macro_rules! write_bytes {
     ($dst:expr, $($bytes:expr),* $(,)?) => {
@@ -174,6 +174,215 @@ fn emit_search_path_if_defined(
     }
 }
 
+fn target_architecture_from_env() -> anyhow::Result<Architecture> {
+    const CARGO_CFG_TARGET_ARCH: &str = "CARGO_CFG_TARGET_ARCH";
+    let arch = env::var_os(CARGO_CFG_TARGET_ARCH).ok_or_else(|| {
+        anyhow::anyhow!(
+            "`{CARGO_CFG_TARGET_ARCH}` is not set, cannot determine the target architecture"
+        )
+    })?;
+    match arch.as_bytes() {
+        b"aarch64" => Ok(Architecture::Aarch64),
+        b"aarch64_ilp32" => Ok(Architecture::Aarch64_Ilp32),
+        b"alpha" => Ok(Architecture::Alpha),
+        b"arm" => Ok(Architecture::Arm),
+        b"avr" => Ok(Architecture::Avr),
+        b"bpf" => Ok(Architecture::Bpf),
+        b"csky" => Ok(Architecture::Csky),
+        b"loongarch32" => Ok(Architecture::LoongArch32),
+        b"loongarch64" => Ok(Architecture::LoongArch64),
+        b"m68k" => Ok(Architecture::M68k),
+        b"mips" => Ok(Architecture::Mips),
+        b"mips64" => Ok(Architecture::Mips64),
+        b"msp430" => Ok(Architecture::Msp430),
+        b"powerpc" => Ok(Architecture::PowerPc),
+        b"powerpc64" => Ok(Architecture::PowerPc64),
+        b"riscv32" => Ok(Architecture::Riscv32),
+        b"riscv64" => Ok(Architecture::Riscv64),
+        b"s390x" => Ok(Architecture::S390x),
+        b"sbf" => Ok(Architecture::Sbf),
+        b"sparc" => Ok(Architecture::Sparc),
+        b"sparc64" => Ok(Architecture::Sparc64),
+        b"wasm32" => Ok(Architecture::Wasm32),
+        b"wasm64" => Ok(Architecture::Wasm64),
+        b"xtensa" => Ok(Architecture::Xtensa),
+        b"x86" => Ok(Architecture::I386),
+        b"x86_64" => Ok(Architecture::X86_64),
+        _ => Err(anyhow::anyhow!(
+            "`{CARGO_CFG_TARGET_ARCH}` references unknown architecture `{}`",
+            arch.display()
+        )),
+    }
+}
+
+fn archive_member_object<'a>(
+    member: object::read::Result<object::read::archive::ArchiveMember<'a>>,
+    archive_path: &Path,
+    archive_data: &'a [u8],
+) -> anyhow::Result<(&'a OsStr, object::File<'a>)> {
+    let member = member.with_context(|| {
+        format!(
+            "failed to process the member of library archive {}",
+            archive_path.display()
+        )
+    })?;
+    let member_name = OsStr::from_bytes(member.name());
+    let member_data = member.data(archive_data).with_context(|| {
+        format!(
+            "failed to read data of static library archive member {} in {}",
+            member_name.display(),
+            archive_path.display()
+        )
+    })?;
+    let obj = object::File::parse(member_data).with_context(|| {
+        format!(
+            "failed to parse data of static library archive member {} as object file",
+            member_name.display(),
+        )
+    })?;
+    Ok((member_name, obj))
+}
+
+fn library_matches_architecture(path: &Path, target_arch: &Architecture) -> anyhow::Result<bool> {
+    let data = match fs::read(path) {
+        Ok(data) => data,
+        Err(err) => {
+            return if err.kind() == io::ErrorKind::NotFound {
+                Ok(false)
+            } else {
+                Err(err).with_context(|| format!("failed to read library {}", path.display()))
+            };
+        }
+    };
+    let archive = ArchiveFile::parse(data.as_slice())
+        .with_context(|| format!("failed to parse library archive {}", path.display()))?;
+    for member in archive.members() {
+        let (_member_name, obj) = archive_member_object(member, path, data.as_slice())?;
+        if obj.architecture() == *target_arch {
+            return Ok(true);
+        }
+    }
+    Ok(false)
+}
+
+fn binary_matches_architecture(path: &Path, target_arch: &Architecture) -> anyhow::Result<bool> {
+    let data = match fs::read(path) {
+        Ok(data) => data,
+        Err(err) if err.kind() == io::ErrorKind::NotFound => return Ok(false),
+        Err(err) => {
+            return Err(err).with_context(|| format!("failed to read binary {}", path.display()));
+        }
+    };
+    let obj = object::File::parse(data.as_slice())
+        .with_context(|| format!("failed to parse binary {} as object file", path.display()))?;
+    Ok(obj.architecture() == *target_arch)
+}
+
+enum Paths<'a> {
+    LdPaths(&'a OsStr),
+    Slice(&'a [PathBuf]),
+}
+
+impl Paths<'_> {
+    fn display(&self) -> PathsDisplay<'_> {
+        match self {
+            Self::LdPaths(ld_paths) => PathsDisplay::LdPaths(ld_paths.display()),
+            Self::Slice(slice) => PathsDisplay::Slice(PathBufSliceDisplay(slice)),
+        }
+    }
+}
+
+enum PathsDisplay<'a> {
+    LdPaths(os_str::Display<'a>),
+    Slice(PathBufSliceDisplay<'a>),
+}
+
+impl Display for PathsDisplay<'_> {
+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
+        match self {
+            Self::LdPaths(display) => display.fmt(f),
+            Self::Slice(display) => display.fmt(f),
+        }
+    }
+}
+
+pub struct PathBufSliceDisplay<'a>(&'a [PathBuf]);
+
+impl Display for PathBufSliceDisplay<'_> {
+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
+        write!(f, "[")?;
+        for (i, p) in self.0.iter().enumerate() {
+            if i != 0 {
+                write!(f, ", ")?;
+            }
+            p.display().fmt(f)?;
+        }
+        write!(f, "]")
+    }
+}
+
+fn check_library<S: Display>(
+    stdout: &mut io::StdoutLock<'_>,
+    ld_paths: Paths<'_>,
+    library: S,
+    paths: Option<Vec<PathBuf>>,
+) -> anyhow::Result<()> {
+    if let Some(paths) = paths {
+        match paths.as_slice() {
+            [] => {
+                anyhow::bail!(
+                    "could not find {library} in any of the following directories: {}",
+                    ld_paths.display()
+                );
+            }
+            [_] => {}
+            paths => {
+                let mut hashes = std::collections::HashMap::new();
+                let mut buffer = [0; 8 * 1024];
+                for path in paths {
+                    use std::{hash::Hasher as _, io::Read as _};
+                    let mut hasher = std::hash::DefaultHasher::new();
+                    let mut file = fs::File::open(path)
+                        .with_context(|| format!("failed to open file {}", path.display()))?;
+                    loop {
+                        let n = file
+                            .read(&mut buffer)
+                            .with_context(|| format!("failed to read file {}", path.display()))?;
+                        if n == 0 {
+                            break;
+                        }
+                        hasher.write(&buffer[..n]);
+                    }
+                    hashes
+                        .entry(hasher.finish())
+                        .or_insert_with(Vec::new)
+                        .push(path);
+                }
+                if hashes.len() > 1 {
+                    write!(
+                        stdout,
+                        "cargo:warning={library} was found in multiple locations: "
+                    )?;
+                    for (i, (hash, paths)) in hashes.iter().enumerate() {
+                        if i != 0 {
+                            write!(stdout, ", ")?;
+                        }
+                        write!(stdout, "[")?;
+                        for (i, path) in paths.iter().enumerate() {
+                            if i != 0 {
+                                write!(stdout, ", ")?;
+                            }
+                            write!(stdout, "{}", path.display())?;
+                        }
+                        write!(stdout, "]=0x{hash:x}")?;
+                    }
+                    writeln!(stdout)?;
+                }
+            }
+        }
+    }
+    Ok(())
+}
 /// Points cargo to static library names of LLVM and dependencies needed by
 /// LLVM.
 ///
@@ -188,64 +397,84 @@ fn emit_search_path_if_defined(
 /// libraries at link time. Since static archives do not explicitly express
 /// which additional libraries are required, we have to determine that set
 /// ourselves using the undefined symbols, and instruct Cargo to link them.
-fn link_llvm_static(stdout: &mut io::StdoutLock<'_>, llvm_lib_dir: &Path) -> anyhow::Result<()> {
-    // Link the library files found inside the directory.
-    let dir_entries = fs::read_dir(llvm_lib_dir)
-        .with_context(|| format!("failed to read directory {}", llvm_lib_dir.display()))?;
-    for entry in dir_entries {
-        let entry = entry.with_context(|| {
-            format!(
-                "failed to read entry of the directory {}",
-                llvm_lib_dir.display()
-            )
-        })?;
-        let file_name = entry.file_name();
-        let file_name = file_name.as_bytes();
-        let Some(trimmed) = file_name
-            .strip_prefix(b"libLLVM")
-            .and_then(|name| name.strip_suffix(b".a"))
-        else {
-            continue;
-        };
-
-        write_bytes!(stdout, "cargo:rustc-link-lib=static=LLVM", trimmed)?;
+fn link_llvm_static(
+    stdout: &mut io::StdoutLock<'_>,
+    target_architecture: &Architecture,
+    llvm_lib_dirs: &[PathBuf],
+) -> anyhow::Result<()> {
+    // Link the LLVM library files (that match the target architecture) and find
+    // libLLVMSupport.a for the inspection below.
+    const LIBLLVM_SUPPORT: &str = "libLLVMSupport.a";
+    let mut libllvm_support = Vec::new();
+    for llvm_lib_dir in llvm_lib_dirs {
+        let dir_entries = fs::read_dir(llvm_lib_dir)
+            .with_context(|| format!("failed to read directory {}", llvm_lib_dir.display()))?;
+        let mut found_first = false;
+        for entry in dir_entries {
+            let entry = entry.with_context(|| {
+                format!(
+                    "failed to read entry of the directory {}",
+                    llvm_lib_dir.display()
+                )
+            })?;
+            let file_name = entry.file_name();
+            if file_name == LIBLLVM_SUPPORT {
+                libllvm_support.push(entry.path());
+            }
+            let file_name = file_name.as_bytes();
+            let Some(trimmed) = file_name
+                .strip_prefix(b"libLLVM")
+                .and_then(|name| name.strip_suffix(b".a"))
+            else {
+                continue;
+            };
+            if !library_matches_architecture(&entry.path(), target_architecture)? {
+                continue;
+            }
+
+            if !found_first {
+                write_bytes!(
+                    stdout,
+                    b"cargo:rustc-link-search=",
+                    llvm_lib_dir.as_os_str().as_bytes(),
+                )?;
+                found_first = true;
+            }
+            write_bytes!(stdout, "cargo:rustc-link-lib=static=LLVM", trimmed)?;
+        }
     }
+    check_library(
+        stdout,
+        Paths::Slice(llvm_lib_dirs),
+        LIBLLVM_SUPPORT,
+        Some(libllvm_support.clone()),
+    )?;
+    let libllvm_support = libllvm_support
+        .into_iter()
+        .next()
+        .expect("check_library ensures at least one libLLVMSupport.a candidate is present");
 
     // Static libraries have no metadata indicating a dependency on other
     // libraries. Given that zlib and zstd might or might be not enabled in
     // different LLVM builds, check whether libLLVMSupport references their
     // symbols.
     let (mut needs_zlib, mut needs_zstd) = (false, false);
-    let llvm_support = llvm_lib_dir.join("libLLVMSupport.a");
-    let data = fs::read(&llvm_support)
-        .with_context(|| format!("failed to read library {}", llvm_support.display()))?;
-    let archive = ArchiveFile::parse(data.as_slice())
-        .with_context(|| format!("failed to parse library archive {}", llvm_support.display()))?;
+    let data = fs::read(&libllvm_support)
+        .with_context(|| format!("failed to read library {}", libllvm_support.display()))?;
+    let archive = ArchiveFile::parse(data.as_slice()).with_context(|| {
+        format!(
+            "failed to parse library archive {}",
+            libllvm_support.display()
+        )
+    })?;
     'outer: for member in archive.members() {
-        let member = member.with_context(|| {
-            format!(
-                "failed to process the member of library archive {}",
-                llvm_support.display()
-            )
-        })?;
-        let member_data = member.data(data.as_slice()).with_context(|| {
-            format!(
-                "failed to read data of static library archive member {}",
-                OsStr::from_bytes(member.name()).display()
-            )
-        })?;
-        let obj = object::File::parse(member_data).with_context(|| {
-            format!(
-                "failed to parse data of static library archive member {} as object file",
-                OsStr::from_bytes(member.name()).display()
-            )
-        })?;
+        let (member_name, obj) = archive_member_object(member, &libllvm_support, data.as_slice())?;
         for symbol in obj.symbols() {
             if symbol.is_undefined() {
                 let sym_name = symbol.name().with_context(|| {
                     format!(
                         "failed to retrieve the symbol name in static library archive member {}",
-                        OsStr::from_bytes(member.name()).display()
+                        member_name.display()
                     )
                 })?;
                 if sym_name.contains("crc32") {
@@ -382,9 +611,7 @@ to an appropriate compiler"
             if let Some(ref mut cxxstdlib_paths) = cxxstdlib_paths {
                 for cxxstdlib in cxxstdlibs.iter_static_filenames() {
                     let cxxstdlib_path = ld_path.join(cxxstdlib);
-                    if cxxstdlib_path.try_exists().with_context(|| {
-                        format!("failed to inspect the file {}", cxxstdlib_path.display(),)
-                    })? {
+                    if library_matches_architecture(&cxxstdlib_path, target_architecture)? {
                         cxxstdlib_paths.push(cxxstdlib_path);
                         found_any = true;
                     }
@@ -392,18 +619,14 @@ to an appropriate compiler"
             }
             if let Some(ref mut zlib_paths) = zlib_paths {
                 let zlib_path = ld_path.join(ZLIB);
-                if zlib_path.try_exists().with_context(|| {
-                    format!("failed to inspect the file {}", zlib_path.display())
-                })? {
+                if library_matches_architecture(&zlib_path, target_architecture)? {
                     zlib_paths.push(zlib_path);
                     found_any = true;
                 }
             }
             if let Some(ref mut zstd_paths) = zstd_paths {
-                let zstd_path = ld_path.join("libzstd.a");
-                if zstd_path.try_exists().with_context(|| {
-                    format!("failed to inspect the file {}", zstd_path.display())
-                })? {
+                let zstd_path = ld_path.join(ZSTD);
+                if library_matches_architecture(&zstd_path, target_architecture)? {
                     zstd_paths.push(zstd_path);
                     found_any = true;
                 }
@@ -417,72 +640,14 @@ to an appropriate compiler"
             }
         }
 
-        fn check_library<S: Display>(
-            stdout: &mut io::StdoutLock<'_>,
-            ld_paths: &OsStr,
-            library: S,
-            paths: Option<Vec<PathBuf>>,
-        ) -> anyhow::Result<()> {
-            if let Some(paths) = paths {
-                match paths.as_slice() {
-                    [] => {
-                        anyhow::bail!(
-                            "could not find {library} in any of the following directories: {}",
-                            ld_paths.display()
-                        );
-                    }
-                    [_] => {}
-                    paths => {
-                        let mut hashes = std::collections::HashMap::new();
-                        let mut buffer = [0; 8 * 1024];
-                        for path in paths {
-                            use std::{hash::Hasher as _, io::Read as _};
-                            let mut hasher = std::hash::DefaultHasher::new();
-                            let mut file = fs::File::open(path).with_context(|| {
-                                format!("failed to open file {}", path.display())
-                            })?;
-                            loop {
-                                let n = file.read(&mut buffer).with_context(|| {
-                                    format!("failed to read file {}", path.display())
-                                })?;
-                                if n == 0 {
-                                    break;
-                                }
-                                hasher.write(&buffer[..n]);
-                            }
-                            hashes
-                                .entry(hasher.finish())
-                                .or_insert_with(Vec::new)
-                                .push(path);
-                        }
-                        if hashes.len() > 1 {
-                            write!(
-                                stdout,
-                                "cargo:warning={library} was found in multiple locations: "
-                            )?;
-                            for (i, (hash, paths)) in hashes.iter().enumerate() {
-                                if i != 0 {
-                                    write!(stdout, ", ")?;
-                                }
-                                write!(stdout, "[")?;
-                                for (i, path) in paths.iter().enumerate() {
-                                    if i != 0 {
-                                        write!(stdout, ", ")?;
-                                    }
-                                    write!(stdout, "{}", path.display())?;
-                                }
-                                write!(stdout, "]=0x{hash:x}")?;
-                            }
-                            writeln!(stdout)?;
-                        }
-                    }
-                }
-            }
-            Ok(())
-        }
-        check_library(stdout, ld_paths, &cxxstdlibs, cxxstdlib_paths)?;
-        check_library(stdout, ld_paths, ZLIB, zlib_paths)?;
-        check_library(stdout, ld_paths, ZSTD, zstd_paths)?;
+        check_library(
+            stdout,
+            Paths::LdPaths(ld_paths),
+            &cxxstdlibs,
+            cxxstdlib_paths,
+        )?;
+        check_library(stdout, Paths::LdPaths(ld_paths), ZLIB, zlib_paths)?;
+        check_library(stdout, Paths::LdPaths(ld_paths), ZSTD, zstd_paths)?;
     }
 
     for cxxstdlib in cxxstdlibs.iter() {
@@ -504,61 +669,67 @@ to an appropriate compiler"
 /// dependencies, since shared libraries contain `DT_NEEDED` entries that
 /// specify the names of libaries that the dynamic linker should link
 /// beforehand.
-fn link_llvm_dynamic(stdout: &mut io::StdoutLock<'_>, llvm_lib_dir: &Path) -> anyhow::Result<()> {
+fn link_llvm_dynamic(
+    stdout: &mut io::StdoutLock<'_>,
+    target_architecture: &Architecture,
+    llvm_lib_dirs: &[PathBuf],
+) -> anyhow::Result<()> {
     const LIB_LLVM: &[u8] = b"libLLVM";
     #[cfg(target_os = "macos")]
     const DYLIB_EXT: &[u8] = b".dylib";
     #[cfg(not(target_os = "macos"))]
     const DYLIB_EXT: &[u8] = b".so";
 
-    let dir_entries = fs::read_dir(llvm_lib_dir).with_context(|| {
-        format!(
-            "failed to read entry of the directory {}",
-            llvm_lib_dir.display()
-        )
-    })?;
-    let libraries = dir_entries
-        .filter_map(|entry| {
-            entry
-                .with_context(|| {
-                    format!(
-                        "failed to read entry of the directory {}",
-                        llvm_lib_dir.display()
-                    )
-                })
-                .map(|entry| {
-                    let mut file_name = entry.file_name().into_encoded_bytes();
-                    if file_name.starts_with(LIB_LLVM) && file_name.ends_with(DYLIB_EXT) {
-                        drop(file_name.drain((file_name.len() - DYLIB_EXT.len())..));
-                        drop(file_name.drain(..LIB_LLVM.len()));
-                        // SAFETY: `file_name` originates from `OsString::into_encoded_bytes`.
-                        // Since then, it was only trimmed.
-                        Some(unsafe { OsString::from_encoded_bytes_unchecked(file_name) })
-                    } else {
-                        None
-                    }
-                })
-                .transpose()
-        })
-        .collect::<anyhow::Result<Vec<_>>>()?;
-    let library = match libraries.as_slice() {
-        [] => {
-            anyhow::bail!(
-                "could not find dynamic libLLVM in the directory {}",
-                llvm_lib_dir.display()
-            );
-        }
-        [library] => library,
-        libraries @ [library, ..] => {
-            writeln!(
-                stdout,
-                "cargo:warning=found multiple libLLVM files in directory {}:
-{libraries:?}",
+    let mut library_dirs = Vec::new();
+    let mut library_names = Vec::new();
+    let mut library_paths = Vec::new();
+    for llvm_lib_dir in llvm_lib_dirs {
+        let dir_entries = fs::read_dir(llvm_lib_dir).with_context(|| {
+            format!(
+                "failed to read entry of the directory {}",
                 llvm_lib_dir.display()
-            )?;
-            library
+            )
+        })?;
+        for entry in dir_entries {
+            let entry = entry.with_context(|| {
+                format!(
+                    "failed to read entry of the directory {}",
+                    llvm_lib_dir.display()
+                )
+            })?;
+            let mut file_name = entry.file_name().into_encoded_bytes();
+            if file_name.starts_with(LIB_LLVM) && file_name.ends_with(DYLIB_EXT) {
+                if !binary_matches_architecture(&entry.path(), target_architecture)? {
+                    continue;
+                }
+                drop(file_name.drain((file_name.len() - DYLIB_EXT.len())..));
+                drop(file_name.drain(..LIB_LLVM.len()));
+                // SAFETY: `file_name` originates from `OsString::into_encoded_bytes`.
+                // Since then, it was only trimmed.
+                let library = unsafe { OsString::from_encoded_bytes_unchecked(file_name) };
+                library_dirs.push(llvm_lib_dir.clone());
+                library_names.push(library);
+                library_paths.push(entry.path());
+            }
         }
-    };
+    }
+    check_library(
+        stdout,
+        Paths::Slice(llvm_lib_dirs),
+        "libLLVM",
+        Some(library_paths),
+    )?;
+    let llvm_lib_dir = library_dirs
+        .first()
+        .expect("`check_library` ensures at least one libLLVM candidate is present");
+    let library = library_names
+        .first()
+        .expect("`check_library` ensures at least one libLLVM candidate is present");
+    write_bytes!(
+        stdout,
+        b"cargo:rustc-link-search=",
+        llvm_lib_dir.as_os_str().as_bytes(),
+    )?;
     write_bytes!(
         stdout,
         "cargo:rustc-link-lib=dylib=LLVM",
@@ -599,24 +770,24 @@ fn main() -> anyhow::Result<()> {
         })
         .or_else(|| env::var_os(PATH).map(|p| (PATH, p)))
         .ok_or_else(|| anyhow!("neither {LLVM_PREFIX} nor {PATH} is set"))?;
+    let target_architecture = target_architecture_from_env()?;
     let llvm_config = env::split_paths(&paths_os)
         .find_map(|dir| {
             let candidate = Path::new(&dir).join("llvm-config");
-            candidate
-                .try_exists()
-                .with_context(|| format!("failed to inspect the file {}", candidate.display()))
-                .map(|exists| exists.then_some(candidate))
-                .transpose()
+            match binary_matches_architecture(&candidate, &target_architecture) {
+                Ok(binary_matches) => binary_matches.then_some(Ok(candidate)),
+                Err(err) => Some(Err(err)),
+            }
         })
         .transpose()?
         .ok_or_else(|| {
             anyhow!(
-                "could not find llvm-config in directories specified by environment
+                "could not find llvm-config targeting architecture {target_architecture:?} in directories specified by environment
 variable `{var_name}` {}",
-                paths_os.display()
+                paths_os.display(),
             )
         })?;
-    let llvm_lib_dir = llvm_config
+    let llvm_basedir = llvm_config
         .parent()
         .and_then(|p| p.parent())
         .ok_or_else(|| {
@@ -624,19 +795,30 @@ variable `{var_name}` {}",
                 "llvm-config location has no parent: {}",
                 llvm_config.display()
             )
-        })?
-        .join("lib");
-    let llvm_lib_dir = fs::canonicalize(&llvm_lib_dir).with_context(|| {
-        format!(
-            "failed to canonicalize LLVM lib directory {}",
-            llvm_lib_dir.display()
-        )
-    })?;
-    write_bytes!(
-        stdout,
-        b"cargo:rustc-link-search=",
-        llvm_lib_dir.as_os_str().as_bytes(),
-    )?;
+        })?;
+    fn maybe_canonicalize_llvm_lib_dir(llvm_lib_dir: PathBuf) -> anyhow::Result<Option<PathBuf>> {
+        match fs::canonicalize(&llvm_lib_dir) {
+            Ok(path) => Ok(Some(path)),
+            Err(err) => {
+                if err.kind() == io::ErrorKind::NotFound {
+                    Ok(None)
+                } else {
+                    Err(err).with_context(|| {
+                        format!(
+                            "failed to canonicalize LLVM lib directory {}",
+                            llvm_lib_dir.display()
+                        )
+                    })
+                }
+            }
+        }
+    }
+    let llvm_lib_dirs = ["lib", "lib64"]
+        .iter()
+        .filter_map(|lib_dir| {
+            maybe_canonicalize_llvm_lib_dir(llvm_basedir.join(lib_dir)).transpose()
+        })
+        .collect::<anyhow::Result<Vec<_>>>()?;
 
-    link_fn(&mut stdout, &llvm_lib_dir)
+    link_fn(&mut stdout, &target_architecture, &llvm_lib_dirs)
 }
